// Code generated by csv2go; DO NOT EDIT.

package model

import (
	"encoding/csv"
	"errors"
	"io"
	"sync"
)

type Struct1CSV struct {
	ch chan Struct1
	once sync.Once
}

func (t *Struct1CSV) ReadChan() <-chan Struct1 {
	t.once.Do(func() { t.ch = make(chan Struct1) })
	return t.ch
}

func (t *Struct1CSV) UnmarshalCSV(r *csv.Reader) error {
	t.once.Do(func() { t.ch = make(chan Struct1) })
	defer close(t.ch)

	header, err := r.Read()
	if err != nil {
		return err
	}

	for {
		record, err := r.Read()
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil
			}
			return err
		}

		var s Struct1
		for i, h := range header {
			v := record[i]
			switch h {
			case "a":
				s.A = v
				s.Alt = v
			case "b":
				s.B = v
			case "c":
				s.C = v
			case "d":
				s.D = v
			case "e":
				s.E = v
			}
		}
		t.ch <- s
	}
}

type Struct2CSV struct {
	ch chan Struct2
	once sync.Once
}

func (t *Struct2CSV) ReadChan() <-chan Struct2 {
	t.once.Do(func() { t.ch = make(chan Struct2) })
	return t.ch
}

func (t *Struct2CSV) UnmarshalCSV(r *csv.Reader) error {
	t.once.Do(func() { t.ch = make(chan Struct2) })
	defer close(t.ch)

	header, err := r.Read()
	if err != nil {
		return err
	}

	for {
		record, err := r.Read()
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil
			}
			return err
		}

		var s Struct2
		for i, h := range header {
			v := record[i]
			switch h {
			case "f":
				s.F = v
				s.Alt = v
			case "g":
				s.G = v
			case "h":
				s.H = v
			case "i":
				s.I = v
			case "j":
				s.J = v
			}
		}
		t.ch <- s
	}
}
